# 弹幕 Hook 功能优化总结

## 📅 日期: 2024-11-27

## 🐛 发现的问题

根据日志分析，发现以下问题：

### 1. WebSocket 消息类型不匹配
**现象：**
```
📦 [Protobuf] 收到消息: payloadType=text/json, logId=...
```

**原因：**
- 抖音直播间使用了 JSON 格式传输部分消息
- 旧代码只处理 `payloadType=msg` 类型
- `text/json` 类型的消息被忽略，导致没有弹幕输出

### 2. 页面加载日志刷屏
**现象：**
```
🔄 直播间页面开始加载: https://...
🔄 直播间页面开始加载: https://...
（重复多次）
```

**原因：**
- 页面内部资源加载和跳转触发多次 `did-start-loading` 事件
- 没有过滤计数，导致日志刷屏

### 3. 大量无害错误警告
**现象：**
```
[直播间 ERROR] ResizeObserver loop completed...
[直播间 WARNING] PerformanceObserver does not support...
[直播间 ERROR] NYI: profileStart...
[直播间 WARNING] eventName is null...
```

**原因：**
- 抖音页面内部的已知错误和警告
- 这些错误不影响弹幕功能
- 日志噪音太多，干扰调试

## ✅ 实施的优化

### 1. 支持 JSON 格式的弹幕消息

#### protobuf-parser-dycast.ts
```typescript
// 新增 text/json 类型处理
else if (payloadType === 'text/json') {
    try {
        const jsonText = new TextDecoder().decode(payload)
        const jsonData = JSON.parse(jsonText)
        
        console.log(`   📄 JSON 消息:`, JSON.stringify(jsonData).substring(0, 200) + '...')
        
        // 从 JSON 中提取弹幕数据
        if (jsonData.messages && Array.isArray(jsonData.messages)) {
            for (const msg of jsonData.messages) {
                const parsedMsg = this.parseJsonMessage(msg)
                if (parsedMsg) {
                    results.push(parsedMsg)
                }
            }
        }
        
        if (results.length > 0) {
            console.log(`   ✅ 从 JSON 解析：${results.length} 条有效弹幕\n`)
        }
        
        return { messages: results, needAck: false, cursor, internalExt, payloadType }
    } catch (error) {
        console.error('   ❌ 解析 JSON 消息失败:', error)
        return { messages: results, needAck: false, cursor, internalExt, payloadType }
    }
}
```

新增 `parseJsonMessage` 方法：
```typescript
private parseJsonMessage(message: any): any | null {
    const method = message.method || message.type || ''
    
    switch (method) {
        case 'WebcastChatMessage':
        case 'chat':
            return { type: 'chat', ... }
        case 'WebcastGiftMessage':
        case 'gift':
            return { type: 'gift', ... }
        // 支持更多类型...
    }
}
```

### 2. 优化 WebSocket Hook 捕获文本消息

#### live-monitor.ts
```typescript
// WebSocket Hook 中新增文本消息处理
else if (typeof data === 'string') {
    // 记录文本消息
    if (!window.__WS_TEXT_COUNT__) {
        window.__WS_TEXT_COUNT__ = 0;
    }
    window.__WS_TEXT_COUNT__++;
    
    // 输出前几条消息用于调试
    if (window.__WS_TEXT_COUNT__ <= 3) {
        const preview = data.length > 200 ? data.substring(0, 200) + '...' : data;
        console.log(`📄 文本消息 #${window.__WS_TEXT_COUNT__}:`, preview);
    }
    
    // 尝试解析 JSON 并发送到主进程
    try {
        const jsonData = JSON.parse(data);
        console.log('__BARRAGE_JSON__:' + data);
    } catch (e) {
        // 不是 JSON，忽略
    }
}
```

### 3. 增加 JSON 消息处理器

#### live-monitor.ts
```typescript
// 在 console-message 监听器中新增
else if (message.startsWith('__BARRAGE_JSON__:')) {
    try {
        const jsonText = message.substring('__BARRAGE_JSON__:'.length)
        const jsonData = JSON.parse(jsonText)
        
        // 处理 JSON 格式的弹幕
        this.handleJsonBarrage(jsonData)
    } catch (error) {
        console.error('❌ 解析 JSON 弹幕失败:', error)
    }
}
```

新增方法：
- `handleJsonBarrage(jsonData)` - 处理 JSON 弹幕数据
- `parseJsonToBarrage(data)` - 将 JSON 转换为统一的弹幕格式

### 4. 减少日志噪音

#### 过滤页面加载日志
```typescript
let loadCount = 0
this.browserView.webContents.on('did-start-loading', () => {
    const url = this.browserView?.webContents.getURL() || ''
    if (!url.startsWith('bytedance://')) {
        loadCount++
        if (loadCount <= 2) {
            console.log('🔄 直播间页面开始加载:', url)
        } else if (loadCount === 3) {
            console.log('🔄 页面继续加载中...（后续加载日志已隐藏）')
        }
    }
})
```

#### 过滤无害的错误和警告
```typescript
const ignoredErrors = [
    'ERR_BLOCKED_BY_CSP',
    'bytedance://',
    'ResizeObserver loop',
    'PerformanceObserver',
    'Electron Security Warning',
    'Content-Security-Policy',
    'NYI: profileStart',
    'NYI: profileEnd',
    'JSB 未实现',
    'decrypt function error',
    'eventName is null',
    'read only property',
    'Refused to frame',
    'attribute viewBox'
]

const shouldIgnore = ignoredErrors.some(err => message.includes(err))

if (!shouldIgnore) {
    const levelStr = ['', 'INFO', 'WARNING', 'ERROR'][level] || 'LOG'
    console.log(`[直播间 ${levelStr}] ${message}`)
}
```

## 🎯 优化后的预期输出

### 启动监控
```
🎥 开始监控直播间: 85335374228
📍 加载地址: https://www.douyin.com/follow/live/85335374228
🔧 开始设置消息拦截器...
✅ 消息拦截器设置完成
✅ 开始加载直播间页面（使用已保存的 Cookie）
```

### 页面加载（只显示前 2 次）
```
🔄 直播间页面开始加载: 
🎯 准备注入 WebSocket Hook 到: https://live.douyin.com/85335374228
✅ 直播间页面加载完成: https://live.douyin.com/85335374228
```

### Hook 注入和 WebSocket 连接
```
[直播间] 🎯 WebSocket Hook 开始注入
[直播间] ✅ WebSocket Hook 安装完成
✅ WebSocket Hook 脚本已注入
[直播间] 🔗 WebSocket 已连接: wss://frontier-im.douyin.com/ws/v2?...
```

### 接收消息（二进制和文本）
```
[直播间] 📊 WebSocket 统计: 已接收 1 条消息
[直播间] 📄 文本消息 #1: {"type":"chat","user":{"nickname":"用户1"},"content":"你好"}

📦 [Protobuf] 收到消息: payloadType=text/json, logId=...
   📄 JSON 消息: {"messages":[...]}
   ✅ 从 JSON 解析：3 条有效弹幕
```

### 弹幕输出
```
💬 [14:35:21] 聊天消息
   👤 用户昵称 (Lv.18)
   内容: 消息内容
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🎁 [14:35:22] 礼物消息
   👤 送礼者 (Lv.42)
   礼物: 玫瑰 x1
   价值: 1 抖币
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

## 📊 改进对比

| 项目 | 优化前 | 优化后 |
|------|--------|--------|
| 支持消息格式 | 仅 Protobuf (msg) | Protobuf + JSON |
| 页面加载日志 | 无限刷屏 | 只显示前 2 次 |
| 错误日志 | 所有错误都显示 | 过滤无害错误 |
| 弹幕捕获率 | 可能漏掉 JSON 消息 | 全部捕获 |
| 日志可读性 | 差（噪音太多） | 好（清晰有序） |

## 🔍 调试建议

### 如果仍然没有弹幕输出

1. **检查文本消息**
   ```
   [直播间] 📄 文本消息 #1: {...}
   ```
   如果看到这个，说明有文本消息，检查 JSON 解析逻辑

2. **检查 JSON 消息结构**
   ```
   📦 [Protobuf] 收到消息: payloadType=text/json
      📄 JSON 消息: {...}
   ```
   查看 JSON 的实际结构，可能需要调整解析代码

3. **临时开启详细日志**
   编辑 `parseJsonMessage` 或 `handleJsonBarrage`，添加：
   ```typescript
   console.log('JSON 完整内容:', JSON.stringify(jsonData, null, 2))
   ```

4. **检查直播间是否真的有弹幕**
   - 在浏览器中打开同一个直播间
   - 确认是否有观众在发弹幕
   - 或者自己发送测试弹幕

## 🎓 技术要点

### 1. 多格式支持
现在系统同时支持：
- **Protobuf 二进制** (ArrayBuffer/Blob)
- **JSON 文本** (String)

### 2. 双重捕获机制
- **浏览器端**: WebSocket Hook 捕获原始消息
- **主进程端**: 分别解析二进制和文本消息

### 3. 噪音过滤
- 页面加载计数限制
- 已知错误白名单
- 条件日志输出

## 🚀 下一步优化方向

1. **自动识别消息格式**
   - 根据实际收到的消息类型动态调整解析策略
   - 减少手动配置

2. **性能优化**
   - 批量处理弹幕（减少 IPC 通信次数）
   - 延迟非关键日志输出

3. **增强 JSON 解析**
   - 支持更多 JSON 消息格式
   - 自动学习 JSON 结构

4. **弹幕去重**
   - 防止同一条弹幕被重复处理
   - 基于消息 ID 或内容哈希

## 📝 注意事项

1. **抖音协议可能变化**
   - 消息格式不是固定的
   - 需要定期更新解析逻辑

2. **不同直播间可能使用不同格式**
   - 大主播：可能用更新的协议
   - 小主播：可能用旧协议
   - 需要都支持

3. **Cookie 过期问题**
   - 如果长时间没有弹幕，检查登录状态
   - 可能需要重新登录

## ✅ 验证清单

- [ ] WebSocket Hook 注入成功
- [ ] WebSocket 连接建立
- [ ] 能接收二进制消息
- [ ] 能接收文本消息
- [ ] JSON 消息能正确解析
- [ ] 弹幕能正常输出
- [ ] 日志清晰无噪音
- [ ] 没有功能性错误

---

**优化完成！** 🎉

现在系统应该能够：
✅ 捕获所有类型的 WebSocket 消息
✅ 解析 Protobuf 和 JSON 格式的弹幕
✅ 输出清晰有序的日志
✅ 过滤无害的错误和警告

重启应用测试即可看到效果！


